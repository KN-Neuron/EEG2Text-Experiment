from src.run import run

DO_USE_DEBUG_MODE = True
DO_USE_MOCK_HEADSET = True

BRAINACCESS_CAP_NAME = "BA MAXI 011"


if __name__ == "__main__":
    run(
        brainaccess_cap_name=BRAINACCESS_CAP_NAME,
        do_use_debug_mode=DO_USE_DEBUG_MODE,
        do_use_mock_headset=DO_USE_MOCK_HEADSET,
    )
from pathlib import Path

import mne
import numpy as np

CHANNELS = [
    "P8",
    "O2",
    "P4",
    "C4",
    "F8",
    "F4",
    "Oz",
    "Cz",
    "Fz",
    "Pz",
    "F3",
    "O1",
    "P7",
    "C3",
    "P3",
    "F7",
    "T8",
    "FC6",
    "CP6",
    "CP2",
    "PO4",
    "FC2",
    "AF4",
    "POz",
    "AFz",
    "AF3",
    "FC1",
    "FC5",
    "T7",
    "CP1",
    "CP5",
    "PO3",
]

VOLTS_IN_MICROVOLT = 10**-6
LOWPASS_FREQUENCY = 1
HIGHPASS_FREQUENCY = 50
SAMPLING_FREQUENCY = 250
MAX_FREQUENCY = SAMPLING_FREQUENCY // 2
BANDSTOP_FREQUENCY = np.arange(50, MAX_FREQUENCY, 50)


def preprocess_data(file_to_check):
    data_path = Path.cwd().parent / "data" / file_to_check
    raw_data = mne.io.read_raw_fif(data_path)
    raw_data.load_data()

    raw_data.pick(CHANNELS)
    raw_data.apply_function(fun=lambda x: x * VOLTS_IN_MICROVOLT)
    raw_data.filter(l_freq=LOWPASS_FREQUENCY, h_freq=HIGHPASS_FREQUENCY)
    raw_data.notch_filter(BANDSTOP_FREQUENCY)

    return raw_data
import random
from dataclasses import dataclass
from pathlib import Path


@dataclass(frozen=True, kw_only=True)
class Sentences:
    polish: list[str]
    english: list[str]


def load_sentences() -> Sentences:
    assets_dir = Path(__file__).parent / "assets"

    with open(assets_dir / "pl.txt", "r", encoding="utf-8") as file:
        polish_sentences = file.read().splitlines()
    random.shuffle(polish_sentences)

    with open(assets_dir / "en.txt", "r", encoding="utf-8") as file:
        english_sentences = file.read().splitlines()
    random.shuffle(english_sentences)

    return Sentences(
        polish=polish_sentences,
        english=english_sentences,
    )
import logging
from pathlib import Path
from threading import Thread
from typing import cast

from data_acquisition.eeg_headset import MockEEGHeadset
from data_acquisition.experiment_runner import ExperimentRunner
from data_acquisition.gui import PygameGui
from data_acquisition.gui.display_mode import FullscreenDisplayMode, WindowedDisplayMode
from data_acquisition.pre_experiment_survey import PreExperimentSurvey

from .app_sequencer_builder import AppSequencerBuilder
from .config import Config
from .constants import (
    BLOCK_COUNT,
    DEBUG_BLOCK_COUNT,
    DEBUG_RELAX_SCREEN_TIMEOUT_MILLIS,
    DEBUG_SENTENCES_IN_BLOCK_COUNT,
    LOGGING_DATETIME_FORMAT,
    LOGGING_LEVEL,
    LOGGING_MESSAGE_FORMAT,
    RELAX_SCREEN_TIMEOUT_MILLIS,
    SENTENCES_IN_BLOCK_COUNT,
    SURVEY_CONFIG_PATH,
    SURVEY_PARTICIPANT_ID_KEY,
)


def run(
    *,
    brainaccess_cap_name: str,
    do_use_debug_mode: bool = False,
    do_use_mock_headset: bool = False,
) -> None:
    survey = PreExperimentSurvey(config_file_path=SURVEY_CONFIG_PATH)
    responses = survey.start_and_get_responses()
    participant_id = cast(str, responses.get(SURVEY_PARTICIPANT_ID_KEY))

    logger = logging.getLogger()
    logger.setLevel(LOGGING_LEVEL)
    (Path().cwd() / "logs").mkdir(exist_ok=True)
    handler = logging.FileHandler(f"logs/{participant_id}.log", encoding="utf-8")
    handler.setLevel(LOGGING_LEVEL)
    formatter = logging.Formatter(
        LOGGING_MESSAGE_FORMAT, datefmt=LOGGING_DATETIME_FORMAT
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    if do_use_mock_headset:
        headset = MockEEGHeadset(logger=logger)
    else:
        from data_acquisition.eeg_headset.brainaccess import BrainAccessV3Headset
        from data_acquisition.eeg_headset.brainaccess.devices import (
            BRAINACCESS_MAXI_32_CHANNEL,
        )

        headset = BrainAccessV3Headset(
            device_name=brainaccess_cap_name,
            device_channels=BRAINACCESS_MAXI_32_CHANNEL,
            logger=logger,
        )

    display_mode = (
        WindowedDisplayMode(width=800, height=600)
        if do_use_debug_mode
        else FullscreenDisplayMode()
    )
    gui = PygameGui(display_mode=display_mode, window_title="NeuroGuard", logger=logger)

    config = Config(
        block_count=(DEBUG_BLOCK_COUNT if do_use_debug_mode else BLOCK_COUNT),
        sentence_count=(
            DEBUG_SENTENCES_IN_BLOCK_COUNT
            if do_use_debug_mode
            else SENTENCES_IN_BLOCK_COUNT
        ),
        relax_screen_timeout_millis=(
            DEBUG_RELAX_SCREEN_TIMEOUT_MILLIS
            if do_use_debug_mode
            else RELAX_SCREEN_TIMEOUT_MILLIS
        ),
    )

    app_sequencer_builder = AppSequencerBuilder(
        gui=gui,
        config=config,
        headset=headset,
        participant_id=participant_id,
        logger=logger,
    )
    sequencer = app_sequencer_builder.set_up_app_sequencer()

    runner = ExperimentRunner(
        gui=gui, screen_sequencer=sequencer, end_callback=gui.stop, logger=logger
    )

    Thread(target=runner.run).start()
    gui.start()
from dataclasses import dataclass

from data_acquisition.gui.event_types import Key

from .constants import (
    BLOCK_COUNT,
    CONTINUE_SCREEN_ADVANCE_KEY,
    CONTINUE_SCREEN_TEXT,
    FIXATION_CROSS_TIMEOUT_RANGE_MILLIS,
    PAUSE_SCREEN_END_ANNOTATION,
    PAUSE_SCREEN_START_ANNOTATION,
    PAUSE_SCREEN_TEXT,
    PAUSE_UNPAUSE_KEY,
    RELAX_SCREEN_END_ANNOTATION,
    RELAX_SCREEN_START_ANNOTATION,
    RELAX_SCREEN_TIMEOUT_MILLIS,
    SENTENCE_SCREEN_ADVANCE_KEY,
    SENTENCE_SCREEN_END_ANNOTATION,
    SENTENCE_SCREEN_START_ANNOTATION,
    SENTENCE_SCREEN_TIMEOUT_MILLIS,
    SENTENCES_IN_BLOCK_COUNT,
)

fixation_cross_timeout_range_start_millis, fixation_cross_timeout_range_end_millis = (
    FIXATION_CROSS_TIMEOUT_RANGE_MILLIS
)


@dataclass
class Config:
    block_count: int = BLOCK_COUNT
    sentence_count: int = SENTENCES_IN_BLOCK_COUNT

    do_show_continue_screen: bool = True
    continue_screen_text: str = CONTINUE_SCREEN_TEXT
    continue_screen_advance_key: Key = CONTINUE_SCREEN_ADVANCE_KEY

    sentence_screen_advance_key: Key = SENTENCE_SCREEN_ADVANCE_KEY
    sentence_screen_timeout_millis: int = SENTENCE_SCREEN_TIMEOUT_MILLIS
    sentence_screen_start_annotation = SENTENCE_SCREEN_START_ANNOTATION
    sentence_screen_end_annotation = SENTENCE_SCREEN_END_ANNOTATION

    fixation_cross_timeout_range_start_millis: int = (
        fixation_cross_timeout_range_start_millis
    )
    fixation_cross_timeout_range_end_millis: int = (
        fixation_cross_timeout_range_end_millis
    )

    pause_unpause_key: Key = PAUSE_UNPAUSE_KEY
    pause_screen_text: str = PAUSE_SCREEN_TEXT
    pause_screen_start_annotation: str = PAUSE_SCREEN_START_ANNOTATION
    pause_screen_end_annotation: str = PAUSE_SCREEN_END_ANNOTATION

    relax_screen_timeout_millis: int = RELAX_SCREEN_TIMEOUT_MILLIS
    relax_screen_start_annotation: str = RELAX_SCREEN_START_ANNOTATION
    relax_screen_end_annotation: str = RELAX_SCREEN_END_ANNOTATION
import logging
from pathlib import Path

from colour import Color
from data_acquisition.gui.event_types import Key

SURVEY_CONFIG_PATH = Path("survey.yml")
SURVEY_PARTICIPANT_ID_KEY = "participant_id"

LOGGING_LEVEL = logging.INFO
LOGGING_MESSAGE_FORMAT = "%(asctime)s - %(message)s"
LOGGING_DATETIME_FORMAT = "%Y-%m-%d %H:%M:%S"

BLOCK_COUNT = 6
DEBUG_BLOCK_COUNT = 2
SENTENCES_IN_BLOCK_COUNT = 50
DEBUG_SENTENCES_IN_BLOCK_COUNT = 3

NON_SENTENCE_SCREEN_BACKGROUND_COLOR = Color("black")
NON_SENTENCE_SCREEN_TEXT_COLOR = Color("white")

CONTINUE_SCREEN_ADVANCE_KEY = Key.SPACE
CONTINUE_SCREEN_TEXT = "Naciśnij SPACJĘ, aby kontynuować badanie."

SENTENCE_SCREEN_ADVANCE_KEY = Key.SPACE
SENTENCE_SCREEN_TIMEOUT_MILLIS = 5 * 1000
SENTENCE_SCREEN_START_ANNOTATION = "SENTENCE_START"
SENTENCE_SCREEN_END_ANNOTATION = "SENTENCE_END"

FIXATION_CROSS_TIMEOUT_RANGE_MILLIS = (500, 1000)

RELAX_SCREEN_TIMEOUT_MILLIS = 60 * 1000
DEBUG_RELAX_SCREEN_TIMEOUT_MILLIS = 5 * 1000
RELAX_SCREEN_START_ANNOTATION = "RELAX_START"
RELAX_SCREEN_END_ANNOTATION = "RELAX_END"

PAUSE_UNPAUSE_KEY = Key.ESCAPE
PAUSE_SCREEN_TEXT = "Naciśnij ESCAPE, aby kontynuować badanie."
PAUSE_SCREEN_START_ANNOTATION = "PAUSE_START"
PAUSE_SCREEN_END_ANNOTATION = "PAUSE_END"
from logging import Logger

from data_acquisition.eeg_headset import EEGHeadset
from data_acquisition.event_manager import (
    CompositeEventManager,
    EventManager,
    FixedTimeoutEventManager,
    KeyPressEventManager,
    RandomTimeoutEventManager,
)
from data_acquisition.eventful_screen import EventfulScreen
from data_acquisition.gui import Gui
from data_acquisition.gui.event_types import Key
from data_acquisition.screens import BlankScreen, FixationCrossScreen, TextScreen
from data_acquisition.sequencers import SimpleScreenSequencer

from .config import Config
from .constants import (
    NON_SENTENCE_SCREEN_BACKGROUND_COLOR,
    NON_SENTENCE_SCREEN_TEXT_COLOR,
)


class SentenceSequencer(SimpleScreenSequencer[None]):
    def __init__(
        self,
        *,
        gui: Gui,
        eeg_headset: EEGHeadset,
        config: Config,
        sentences: list[str],
        logger: Logger,
    ):
        super().__init__(gui=gui, logger=logger)

        self._sentences = sentences
        self._eeg_headset = eeg_headset
        self._config = config
        self._logger = logger

        self._continue_screen_event_manager = KeyPressEventManager(
            gui=self._gui, key=config.continue_screen_advance_key, logger=logger
        )
        self._build_sentence_screen_event_manager(
            advance_key=config.sentence_screen_advance_key,
            timeout_millis=config.sentence_screen_timeout_millis,
        )
        self._build_fixation_cross_screen_event_manager(
            timeout_range_start_millis=config.fixation_cross_timeout_range_start_millis,
            timeout_range_end_millis=config.fixation_cross_timeout_range_end_millis,
        )
        self._build_pause_unpause_event_manager(key=config.pause_unpause_key)
        self._build_relax_screen_event_manager(
            timeout_millis=config.relax_screen_timeout_millis
        )

        self._pause_screen = TextScreen(
            gui=self._gui,
            text=config.pause_screen_text,
            text_color=NON_SENTENCE_SCREEN_TEXT_COLOR,
            background_color=NON_SENTENCE_SCREEN_BACKGROUND_COLOR,
        )
        self._continue_screen = TextScreen(
            gui=self._gui,
            text=config.continue_screen_text,
            text_color=NON_SENTENCE_SCREEN_TEXT_COLOR,
            background_color=NON_SENTENCE_SCREEN_BACKGROUND_COLOR,
        )

        self._was_first_screen_shown = False
        self._was_fixation_cross_shown = False
        self._was_paused = False
        self._was_relax_screen_shown = False
        self._index = 0

    def _build_sentence_screen_event_manager(
        self,
        *,
        advance_key: Key,
        timeout_millis: int,
    ) -> None:
        key_event_manager = KeyPressEventManager(
            gui=self._gui, key=advance_key, logger=self._logger
        )
        timeout_event_manager = FixedTimeoutEventManager(
            gui=self._gui, timeout_millis=timeout_millis, logger=self._logger
        )

        self._sentence_screen_event_manager = CompositeEventManager(
            event_managers=[key_event_manager, timeout_event_manager],
            logger=self._logger,
        )
        self._sentence_screen_event_manager.register_callback(
            lambda _: self._eeg_headset.annotate(
                self._config.sentence_screen_end_annotation
            )
        )

    def _build_fixation_cross_screen_event_manager(
        self, *, timeout_range_start_millis: int, timeout_range_end_millis: int
    ) -> None:
        self._fixation_cross_screen_event_manager = RandomTimeoutEventManager(
            gui=self._gui,
            timeout_min_millis=timeout_range_start_millis,
            timeout_max_millis=timeout_range_end_millis,
            logger=self._logger,
        )

    def _build_pause_unpause_event_manager(self, *, key: Key) -> None:
        self._pause_unpause_event_manager = KeyPressEventManager(
            gui=self._gui, key=key, logger=self._logger
        )

    def _build_relax_screen_event_manager(self, *, timeout_millis: int) -> None:
        self._relax_screen_event_manager = FixedTimeoutEventManager(
            gui=self._gui, timeout_millis=timeout_millis, logger=self._logger
        )

        self._relax_screen_event_manager.register_callback(
            lambda _: self._eeg_headset.annotate(
                self._config.relax_screen_end_annotation
            )
        )

    def _get_next(self) -> EventfulScreen[None]:
        if not self._was_first_screen_shown and self._config.do_show_continue_screen:
            return self._get_continue_screen()
        self._was_first_screen_shown = True

        if self._was_paused:
            return self._get_pause_screen()

        if self._index >= self._config.sentence_count:
            return self._get_relax_screen()

        if not self._was_fixation_cross_shown:
            return self._get_fixation_cross_screen()

        return self._get_sentence_screen()

    def _get_continue_screen(self) -> EventfulScreen[None]:
        self._was_first_screen_shown = True

        continue_screen = self._continue_screen

        screen = EventfulScreen(
            screen=continue_screen,
            event_manager=self._continue_screen_event_manager.clone(),
        )

        return screen

    def _get_pause_screen(self) -> EventfulScreen[None]:
        self._was_paused = False

        self._index -= 1

        pause_event_manager = self._pause_unpause_event_manager.clone()
        pause_event_manager.register_callback(
            lambda _: self._eeg_headset.annotate(
                self._config.pause_screen_end_annotation
            )
        )

        screen = EventfulScreen(
            screen=self._pause_screen,
            event_manager=pause_event_manager,
            screen_show_callback=lambda: self._eeg_headset.annotate(
                self._config.pause_screen_start_annotation
            ),
        )

        return screen

    def _get_relax_screen(self) -> EventfulScreen[None]:
        if self._was_relax_screen_shown:
            raise StopIteration

        self._was_relax_screen_shown = True

        relax_screen = BlankScreen(gui=self._gui)

        screen = EventfulScreen(
            screen=relax_screen,
            event_manager=self._relax_screen_event_manager.clone(),
            screen_show_callback=lambda: self._eeg_headset.annotate(
                self._config.relax_screen_start_annotation
            ),
        )

        return screen

    def _get_fixation_cross_screen(self) -> EventfulScreen[None]:
        self._was_fixation_cross_shown = True

        screen = FixationCrossScreen(gui=self._gui)
        event_manager = self._get_event_manager_with_pause(
            self._fixation_cross_screen_event_manager
        )
        screen = EventfulScreen(screen=screen, event_manager=event_manager)

        return screen

    def _get_sentence_screen(self) -> EventfulScreen[None]:
        self._was_fixation_cross_shown = False
        self._index += 1

        text = self._sentences.pop()

        screen = TextScreen(gui=self._gui, text=text)
        event_manager = self._get_event_manager_with_pause(
            self._sentence_screen_event_manager
        )
        screen = EventfulScreen(
            screen=screen,
            event_manager=event_manager,
            screen_show_callback=lambda: self._eeg_headset.annotate(
                self._config.sentence_screen_start_annotation
            ),
        )

        self._logger.info(f"Showing screen with sentence: {text}")

        return screen

    def _get_event_manager_with_pause(
        self, event_manager: EventManager[None]
    ) -> EventManager[None]:
        pause_event_manager = self._pause_unpause_event_manager.clone()
        pause_event_manager.register_callback(self._mark_as_paused)

        pause_screen_event_manager = CompositeEventManager(
            event_managers=[pause_event_manager, event_manager.clone()],
            logger=self._logger,
        )

        return pause_screen_event_manager

    def _mark_as_paused(self, _: None) -> None:
        self._was_paused = True
import itertools
from copy import copy
from logging import Logger
from pathlib import Path
from typing import Sequence

from data_acquisition.eeg_headset import EEGHeadset
from data_acquisition.gui import Gui
from data_acquisition.sequencers import BlockScreenSequencer, ScreenSequencer

from .config import Config
from .sentence_sequencer import SentenceSequencer
from .sentences import Sentences, load_sentences


class AppSequencerBuilder:
    def __init__(
        self,
        *,
        gui: Gui,
        config: Config,
        headset: EEGHeadset,
        participant_id: str,
        logger: Logger,
    ):
        self._gui = gui
        self._config = config
        self._headset = headset
        self._participant_id = participant_id
        self._logger = logger

    def set_up_app_sequencer(self) -> ScreenSequencer[None]:
        self._set_up_save_directory()

        sentences = load_sentences()
        sequencers = self._build_sequencers_from_sentences(sentences)

        return BlockScreenSequencer(
            sequencers=sequencers,
            block_start_callback=lambda _: self._headset.start(),
            block_end_callback=lambda block_number: self._headset.stop_and_save_at_path(
                self._eeg_save_dir / f"{block_number}_raw.fif"
            ),
            logger=self._logger,
        )

    def _set_up_save_directory(self) -> None:
        self._eeg_save_dir = Path("data") / self._participant_id
        self._eeg_save_dir.mkdir(parents=True)

    def _build_sequencers_from_sentences(
        self, sentences: Sentences
    ) -> Sequence[ScreenSequencer[None]]:
        sequencers: list[ScreenSequencer[None]] = []

        sentences_in_blocks = itertools.islice(
            itertools.cycle([sentences.polish, sentences.english]),
            self._config.block_count,
        )

        for idx, sentences_in_block in enumerate(sentences_in_blocks):
            config = copy(self._config)
            config.do_show_continue_screen = idx != 0

            sequencer = SentenceSequencer(
                gui=self._gui,
                eeg_headset=self._headset,
                config=config,
                sentences=sentences_in_block,
                logger=self._logger,
            )

            sequencers.append(sequencer)

        return sequencers
